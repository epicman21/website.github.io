<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Stick Shrine — P2P Stick Fight</title>
<style>
  :root {
    --bg: #0b0e12; --panel:#10151c; --ink:#e6edf3; --muted:#93a1b3; --accent:#7aa2ff;
    --ok:#34c759; --warn:#ffd60a; --err:#ff453a;
  }
  * { box-sizing: border-box; }
  html, body { height:100%; margin:0; background:radial-gradient(1000px 500px at 10% 0%, #0f1520 0%, #0b0e12 60%) no-repeat, var(--bg); color:var(--ink); font:14px/1.35 ui-sans-serif, system-ui, "Segoe UI", Roboto, Arial; }
  .wrap { max-width: 1000px; margin: 20px auto; padding: 0 16px 24px; }
  header { display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; }
  h1 { font-size:20px; margin:0; letter-spacing:.2px; }
  .hint { color:var(--muted); font-size:12px; }
  .panel { margin-top:10px; background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(0,0,0,.08)); border:1px solid rgba(255,255,255,.06); border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.05); padding:12px; }
  .toolbar { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
  button, .toggle, .seg {
    background:#0e1420; color:var(--ink); border:1px solid rgba(255,255,255,.12); border-radius:10px; padding:8px 10px; cursor:pointer;
    box-shadow:0 1px 0 rgba(255,255,255,.06) inset, 0 4px 14px rgba(0,0,0,.25);
  }
  button:hover, .toggle:hover, .seg:hover { background:#121a2a; border-color:rgba(255,255,255,.2); }
  .toggle { display:inline-flex; align-items:center; gap:6px; }
  .segrow { display:flex; gap:6px; flex-wrap:wrap; }
  .seg[data-active="1"] { background:#162235; border-color:rgba(122,162,255,.6); }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .flex { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  .kbd { font:600 12px/1 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono"; background:#0f1625; border:1px solid rgba(255,255,255,.14); padding:2px 6px; border-radius:6px; color:#cfe0ff; }
  .status { font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono"; color:#cfe0ff; }
  .status.ok { color:var(--ok); } .status.warn { color:var(--warn); } .status.err { color:var(--err); }
  canvas { display:block; margin:10px auto 0; background:linear-gradient(#1c2431, #151b26); border:1px solid rgba(255,255,255,.06); border-radius:12px; box-shadow:inset 0 1px 0 rgba(255,255,255,.04), 0 10px 30px rgba(0,0,0,.35); }
  .footer { display:flex; justify-content:space-between; align-items:center; gap:12px; color:var(--muted); flex-wrap:wrap; margin-top:10px; }
  /* Modal */
  .modal { position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.55); padding:16px; }
  .modal[open] { display:grid; }
  .sheet { width:min(820px,100%); background:var(--panel); border:1px solid rgba(255,255,255,.1); border-radius:12px; padding:16px; box-shadow:0 20px 60px rgba(0,0,0,.5); }
  .sheet h2 { margin:0 0 8px; font-size:16px; }
  textarea, input[type="text"] {
    width:100%; background:#0e1420; color:var(--ink); border:1px solid rgba(255,255,255,.14); border-radius:10px; padding:10px;
    font:12px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono";
  }
  textarea { height:160px; resize:vertical; }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Stick Shrine — P2P Stick Fight</h1>
      <div class="hint">Local 2‑player or peer‑to‑peer. Static‑host friendly. LAN‑only option.</div>
    </header>

    <div class="panel">
      <div class="toolbar">
        <div class="row">
          <button id="mpBtn" title="Peer-to-peer multiplayer via WebRTC">Multiplayer</button>
          <span id="p2pBadge" class="status">P2P: disconnected</span>
        </div>
        <div class="row">
          <button id="resetBtn" title="Restart round">Reset</button>
          <label class="toggle" title="Show debug overlay">
            <input type="checkbox" id="dbgToggle" />
            <span>Debug</span>
          </label>
        </div>
      </div>

      <canvas id="cv" width="960" height="540" aria-label="Stick fight arena"></canvas>

      <div class="footer">
        <div>
          <span class="kbd">P1</span> A/D move, W jump, J punch •
          <span class="kbd">P2</span> ←/→ move, ↑ jump, ; punch •
          <span class="kbd">R</span> reset
        </div>
        <div class="hint">Host is authoritative when connected.</div>
      </div>
    </div>
  </div>

  <!-- P2P Modal -->
  <div class="modal" id="p2pModal" aria-hidden="true">
    <div class="sheet">
      <h2>Multiplayer — WebRTC (manual signaling)</h2>
      <div class="row" style="justify-content:space-between">
        <div class="segrow">
          <button id="tabHost" class="seg" data-active="1">Host</button>
          <button id="tabJoin" class="seg" data-active="0">Join</button>
        </div>
        <div class="row">
          <label class="toggle" title="No STUN servers (best for same LAN). Uncheck to allow public STUN for internet peers.">
            <input type="checkbox" id="lanOnly" checked />
            <span>LAN‑only</span>
          </label>
          <span id="p2pState" class="status">idle</span>
        </div>
      </div>

      <div id="hostPane">
        <p class="hint">1) Create offer. 2) Send it to your peer. 3) Paste their answer below.</p>
        <div class="row" style="justify-content:flex-start">
          <button id="hostCreate">Create Offer</button>
          <button id="hostCopy">Copy Offer</button>
          <button id="hostReset">Reset</button>
        </div>
        <label class="hint">Offer (share this):</label>
        <textarea id="hostOffer" spellcheck="false" placeholder="Host offer will appear here"></textarea>
        <label class="hint">Paste peer answer:</label>
        <textarea id="hostAnswer" spellcheck="false" placeholder="Paste answer here"></textarea>
        <div class="row" style="justify-content:flex-end">
          <button id="hostAccept">Accept Answer</button>
          <button id="p2pClose">Close</button>
        </div>
      </div>

      <div id="joinPane" style="display:none">
        <p class="hint">1) Paste host offer. 2) Create answer. 3) Send answer back.</p>
        <label class="hint">Paste host offer:</label>
        <textarea id="joinOffer" spellcheck="false" placeholder="Paste offer here"></textarea>
        <div class="row" style="justify-content:flex-start">
          <button id="joinAccept">Accept Offer & Create Answer</button>
          <button id="joinCopy">Copy Answer</button>
          <button id="joinReset">Reset</button>
        </div>
        <label class="hint">Answer (share this):</label>
        <textarea id="joinAnswer" spellcheck="false" placeholder="Your answer will appear here"></textarea>
        <div class="row" style="justify-content:flex-end">
          <button id="p2pClose2">Close</button>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Game config =====
  const W = 960, H = 540;
  const GROUND_Y = H - 60;
  const GRAV = 0.9, FRICTION = 0.85, AIR_FRICTION = 0.98;
  const MOVE = 5.0, JUMP = 16.5;
  const PUNCH_CD = 350;   // ms
  const PUNCH_LEN = 120;  // ms
  const PUNCH_RANGE = 46; // px from torso
  const PUNCH_DMG = 22;
  const MAX_HP = 100;
  const RESPAWN_MS = 1500;

  // ===== Canvas =====
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");

  // ===== UI =====
  const resetBtn = document.getElementById("resetBtn");
  const dbgToggle = document.getElementById("dbgToggle");
  const mpBtn = document.getElementById("mpBtn");
  const p2pBadge = document.getElementById("p2pBadge");
  const p2pModal = document.getElementById("p2pModal");
  const p2pState = document.getElementById("p2pState");
  const tabHost = document.getElementById("tabHost");
  const tabJoin = document.getElementById("tabJoin");
  const hostPane = document.getElementById("hostPane");
  const joinPane = document.getElementById("joinPane");
  const lanOnly = document.getElementById("lanOnly");
  const hostCreate = document.getElementById("hostCreate");
  const hostCopy = document.getElementById("hostCopy");
  const hostReset = document.getElementById("hostReset");
  const hostOffer = document.getElementById("hostOffer");
  const hostAnswer = document.getElementById("hostAnswer");
  const hostAccept = document.getElementById("hostAccept");
  const joinOffer = document.getElementById("joinOffer");
  const joinAccept = document.getElementById("joinAccept");
  const joinCopy = document.getElementById("joinCopy");
  const joinReset = document.getElementById("joinReset");
  const joinAnswer = document.getElementById("joinAnswer");
  const p2pClose = document.getElementById("p2pClose");
  const p2pClose2 = document.getElementById("p2pClose2");

  // ===== Game state =====
  const makePlayer = (x) => ({
    x, y: GROUND_Y, vx: 0, vy: 0,
    facing: 1, // 1 right, -1 left
    onGround: true,
    hp: MAX_HP,
    punchT: 0, // time left of punch anim (ms)
    cd: 0,     // cooldown ms
    dead: false,
    respawnAt: 0,
    score: 0,
  });
  let P1 = makePlayer(W*0.3), P2 = makePlayer(W*0.7);
  P2.facing = -1;

  const input = {
    // local keys for P1 and P2 (always active for couch play)
    p1: { left:false, right:false, jump:false, punch:false },
    p2: { left:false, right:false, jump:false, punch:false }
  };
  const remoteInput = { left:false, right:false, jump:false, punch:false };

  // Networking role: null (offline), "host", "join"
  let role = null;
  let pc = null, dc = null;
  let lastNetStateSent = 0;

  // ===== Helpers =====
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  // ===== Physics & combat =====
  function applyInput(pl, inp) {
    if (pl.dead) return;
    // horizontal
    if (inp.left && !inp.right) { pl.vx -= pl.onGround ? MOVE : MOVE*0.6; pl.facing = -1; }
    else if (inp.right && !inp.left) { pl.vx += pl.onGround ? MOVE : MOVE*0.6; pl.facing = 1; }
    // jump (edge-triggered handled outside)
    // punch
    // (edge-triggered handled outside)
  }

  function integrate(pl, dt) {
    // friction
    pl.vx *= pl.onGround ? FRICTION : AIR_FRICTION;
    // gravity
    pl.vy += GRAV;
    // move
    pl.x += pl.vx * dt/16.7;
    pl.y += pl.vy * dt/16.7;

    // ground collide
    if (pl.y >= GROUND_Y) {
      pl.y = GROUND_Y;
      pl.vy = 0;
      pl.onGround = true;
    } else {
      pl.onGround = false;
    }

    // walls
    if (pl.x < 40) { pl.x = 40; pl.vx = 0; }
    if (pl.x > W-40) { pl.x = W-40; pl.vx = 0; }

    // timers
    if (pl.punchT > 0) pl.punchT -= dt;
    if (pl.cd > 0) pl.cd -= dt;
  }

  function tryJump(pl, wasDown, isDown) {
    if (!wasDown && isDown && pl.onGround && !pl.dead) {
      pl.vy = -JUMP;
      pl.onGround = false;
    }
  }

  function tryPunch(att, def, wasDown, isDown, now) {
    if (!att.dead && !wasDown && isDown && att.cd <= 0) {
      att.punchT = PUNCH_LEN;
      att.cd = PUNCH_CD;
      // hitbox: small segment in facing dir
      const hx = att.x + att.facing * (PUNCH_RANGE);
      const hy = att.y - 30; // torso height
      const dx = def.x - hx;
      const dy = (def.y - 30) - hy;
      const dist = Math.hypot(dx, dy);
      if (dist < 40) {
        def.hp -= PUNCH_DMG;
        def.vx += att.facing * 8;
        def.vy = -6;
        if (def.hp <= 0 && !def.dead) {
          def.dead = true;
          def.respawnAt = now + RESPAWN_MS;
          att.score += 1;
        }
      }
    }
  }

  function respawnIfReady(pl, now) {
    if (pl.dead && now >= pl.respawnAt) {
      Object.assign(pl, makePlayer(pl === P1 ? W*0.3 : W*0.7));
      pl.facing = (pl === P1) ? 1 : -1;
    }
  }

  // ===== Rendering =====
  function draw() {
    // background
    ctx.clearRect(0,0,W,H);
    // arena floor
    ctx.fillStyle = "#0f1520";
    ctx.fillRect(0, GROUND_Y+20, W, H-(GROUND_Y+20));
    ctx.fillStyle = "#121a2a";
    ctx.fillRect(0, GROUND_Y, W, 20);

    drawPlayer(P1, "#7aa2ff");
    drawPlayer(P2, "#ff9f7a");

    // HUD
    drawHUD();
  }

  function drawPlayer(p, color) {
    // shadow
    ctx.fillStyle = "rgba(0,0,0,0.3)";
    ctx.beginPath();
    ctx.ellipse(p.x, GROUND_Y+10, 22, 8, 0, 0, Math.PI*2);
    ctx.fill();

    // stick figure
    ctx.strokeStyle = color;
    ctx.lineWidth = 4;
    ctx.lineCap = "round";
    // torso
    const headY = p.y - 60;
    const torsoY = p.y - 20;
    ctx.beginPath();
    ctx.moveTo(p.x, headY+14);
    ctx.lineTo(p.x, torsoY);
    ctx.stroke();
    // head
    ctx.beginPath();
    ctx.arc(p.x, headY, 14, 0, Math.PI*2);
    ctx.stroke();
    // legs
    ctx.beginPath();
    ctx.moveTo(p.x, torsoY);
    ctx.lineTo(p.x - 14, p.y);
    ctx.moveTo(p.x, torsoY);
    ctx.lineTo(p.x + 14, p.y);
    ctx.stroke();
    // arms
    const armLen = 26;
    const ang = p.punchT > 0 ? (p.facing === 1 ? 0.0 : Math.PI) : (p.facing === 1 ? -0.4 : Math.PI+0.4);
    const ax = p.x + Math.cos(ang) * armLen;
    const ay = (p.y - 40) + Math.sin(ang) * armLen;
    ctx.beginPath();
    ctx.moveTo(p.x, p.y - 40);
    ctx.lineTo(ax, ay);
    ctx.stroke();

    if (dbgToggle.checked) {
      ctx.fillStyle = "#cfe0ff";
      ctx.font = "12px ui-monospace";
      ctx.fillText(`x:${p.x.toFixed(1)} y:${p.y.toFixed(1)} vx:${p.vx.toFixed(2)} vy:${p.vy.toFixed(2)}`, p.x-40, p.y-80);
    }
  }

  function drawHUD() {
    // HP bars
    const bar = (x, y, hp, color, label, score) => {
      ctx.fillStyle = "rgba(255,255,255,0.08)";
      ctx.fillRect(x, y, 320, 14);
      ctx.fillStyle = color;
      ctx.fillRect(x, y, 320 * clamp(hp/MAX_HP, 0, 1), 14);
      ctx.strokeStyle = "rgba(255,255,255,0.2)";
      ctx.strokeRect(x, y, 320, 14);
      ctx.fillStyle = "#cfe0ff";
      ctx.font = "12px ui-monospace";
      ctx.fillText(`${label} HP:${Math.max(0, hp)}  KOs:${score}`, x, y-6);
    };
    bar(20, 24, P1.hp, "#7aa2ff", "P1", P1.score);
    bar(W-340, 24, P2.hp, "#ff9f7a", "P2", P2.score);

    if (role) {
      ctx.fillStyle = "#93a1b3";
      ctx.font = "12px ui-monospace";
      ctx.fillText(`Net: ${role}`, 20, 48);
    }
  }

  // ===== Game loop =====
  let last = performance.now();
  let prevJump = { p1:false, p2:false };
  let prevPunch = { p1:false, p2:false };

  function step(now) {
    const dt = clamp(now - last, 0, 50);
    last = now;

    // inputs: local for couch play always active
    const p1In = role === "join" ? remoteInput : input.p1; // join uses host-fed input for P1 if host is controlling P1
    const p2In = role === "host" ? remoteInput : input.p2; // host uses remote for P2 when connected

    // apply inputs
    applyInput(P1, p1In);
    applyInput(P2, p2In);

    // edge-triggered actions
    tryJump(P1, prevJump.p1, p1In.jump);
    tryJump(P2, prevJump.p2, p2In.jump);
    tryPunch(P1, P2, prevPunch.p1, p1In.punch, now);
    tryPunch(P2, P1, prevPunch.p2, p2In.punch, now);
    prevJump.p1 = p1In.jump; prevJump.p2 = p2In.jump;
    prevPunch.p1 = p1In.punch; prevPunch.p2 = p2In.punch;

    // integrate physics
    integrate(P1, dt);
    integrate(P2, dt);

    // respawn
    respawnIfReady(P1, now);
    respawnIfReady(P2, now);

    // net authority: host sends state snapshots
    if (role === "host" && dc && dc.readyState === "open") {
      if (now - lastNetStateSent > 50) {
        lastNetStateSent = now;
        p2pSend({
          t:"state",
          p1: packPlayer(P1),
          p2: packPlayer(P2)
        });
      }
    }

    draw();
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

  function packPlayer(p) {
    return { x:p.x, y:p.y, vx:p.vx, vy:p.vy, f:p.facing, g:p.onGround?1:0, hp:p.hp, pt:Math.max(0, p.punchT|0), cd:Math.max(0, p.cd|0), d:p.dead?1:0, rs:p.respawnAt|0, sc:p.score|0 };
  }
  function unpackInto(dst, src) {
    if (!src) return;
    dst.x = src.x; dst.y = src.y; dst.vx = src.vx; dst.vy = src.vy;
    dst.facing = src.f; dst.onGround = !!src.g; dst.hp = src.hp;
    dst.punchT = src.pt; dst.cd = src.cd; dst.dead = !!src.d; dst.respawnAt = src.rs; dst.score = src.sc;
  }

  // ===== Controls =====
  const keyMapDown = {
    // P1
    "a":"p1.left", "d":"p1.right", "w":"p1.jump", "j":"p1.punch",
    // P2
    "arrowleft":"p2.left", "arrowright":"p2.right", "arrowup":"p2.jump", ";":"p2.punch"
  };
  const keyMapUp = keyMapDown;

  window.addEventListener("keydown", (e) => {
    if (e.repeat) return;
    if (e.key.toLowerCase() === "r") { resetRound(); return; }
    const k = (e.key.length === 1 ? e.key : e.key).toLowerCase();
    const map = keyMapDown[k];
    if (map) {
      const [who, what] = map.split(".");
      input[who][what] = true;
      // send my inputs over net
      if (dc && dc.readyState === "open") {
        const mine = (role === "host") ? "p1" : (role === "join") ? "p2" : null;
        if (mine === who) p2pSend({ t:"inp", i: what, v: 1 });
      }
      e.preventDefault();
    }
  });
  window.addEventListener("keyup", (e) => {
    const k = (e.key.length === 1 ? e.key : e.key).toLowerCase();
    const map = keyMapUp[k];
    if (map) {
      const [who, what] = map.split(".");
      input[who][what] = false;
      if (dc && dc.readyState === "open") {
        const mine = (role === "host") ? "p1" : (role === "join") ? "p2" : null;
        if (mine === who) p2pSend({ t:"inp", i: what, v: 0 });
      }
      e.preventDefault();
    }
  });

  resetBtn.addEventListener("click", resetRound);
  function resetRound() {
    P1 = makePlayer(W*0.3); P1.facing = 1;
    P2 = makePlayer(W*0.7); P2.facing = -1;
  }

  // ===== Multiplayer (manual signaling) =====
  mpBtn.addEventListener("click", () => openP2P());
  p2pClose.addEventListener("click", () => closeP2P());
  p2pClose2.addEventListener("click", () => closeP2P());
  tabHost.addEventListener("click", () => switchTab(true));
  tabJoin.addEventListener("click", () => switchTab(false));
  hostCreate.addEventListener("click", async () => {
    resetP2P();
    role = "host";
    try {
      pc = buildPC();
      dc = pc.createDataChannel("sticks", { ordered:true });
      attachDC(dc);
      setState("creating offer…");
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await waitIce(pc);
      hostOffer.value = JSON.stringify(pc.localDescription);
      setState("share the offer");
    } catch (e) { setState("offer error", true); }
  });
  hostCopy.addEventListener("click", async () => {
    try { await navigator.clipboard.writeText(hostOffer.value || ""); setState("offer copied"); } catch {}
  });
  hostAccept.addEventListener("click", async () => {
    try {
      const ans = JSON.parse((hostAnswer.value || "").trim());
      await pc.setRemoteDescription(ans);
      setState("waiting for datachannel…");
    } catch { setState("invalid answer", true); }
  });
  hostReset.addEventListener("click", () => {
    hostOffer.value = ""; hostAnswer.value = "";
    resetP2P(); setState("idle");
  });

  joinAccept.addEventListener("click", async () => {
    resetP2P();
    role = "join";
    try {
      pc = buildPC();
      pc.ondatachannel = (ev) => { dc = ev.channel; attachDC(dc); };
      const off = JSON.parse((joinOffer.value || "").trim());
      await pc.setRemoteDescription(off);
      setState("creating answer…");
      const ans = await pc.createAnswer();
      await pc.setLocalDescription(ans);
      await waitIce(pc);
      joinAnswer.value = JSON.stringify(pc.localDescription);
      setState("send answer to host");
    } catch { setState("invalid offer", true); }
  });
  joinCopy.addEventListener("click", async () => {
    try { await navigator.clipboard.writeText(joinAnswer.value || ""); setState("answer copied"); } catch {}
  });
  joinReset.addEventListener("click", () => {
    joinOffer.value = ""; joinAnswer.value = "";
    resetP2P(); setState("idle");
  });

  function openP2P() { p2pModal.setAttribute("open",""); p2pModal.setAttribute("aria-hidden","false"); }
  function closeP2P() { p2pModal.removeAttribute("open"); p2pModal.setAttribute("aria-hidden","true"); }

  function switchTab(isHost) {
    tabHost.dataset.active = isHost ? "1":"0";
    tabJoin.dataset.active = isHost ? "0":"1";
    hostPane.style.display = isHost ? "" : "none";
    joinPane.style.display = isHost ? "none" : "";
  }

  function buildPC() {
    const cfg = lanOnly.checked ? { iceServers: [] } : { iceServers: [
      { urls: ["stun:stun.l.google.com:19302","stun:global.stun.twilio.com:3478"] }
    ]};
    const peer = new RTCPeerConnection(cfg);
    peer.onconnectionstatechange = () => {
      const s = peer.connectionState;
      p2pBadge.textContent = "P2P: " + s;
      if (s === "connected") setState("connected", false, true);
      if (s === "failed") setState("failed", true);
      if (s === "disconnected" || s === "closed") setState("closed");
    };
    return peer;
  }
  function attachDC(channel) {
    channel.onopen = () => { setState("channel open", false, true); p2pBadge.textContent = "P2P: connected"; };
    channel.onclose = () => { setState("channel closed"); p2pBadge.textContent = "P2P: disconnected"; };
    channel.onerror = () => { setState("channel error", true); };
    channel.onmessage = (ev) => {
      try {
        const msg = JSON.parse(typeof ev.data === "string" ? ev.data : new TextDecoder().decode(ev.data));
        handleMsg(msg);
      } catch {}
    };
    // on connect, host sends authoritative state
    if (role === "host") p2pSend({ t:"state", p1: packPlayer(P1), p2: packPlayer(P2) });
  }
  function setState(text, isErr=false, isOk=false) {
    p2pState.textContent = text;
    p2pState.className = "status" + (isErr ? " err" : isOk ? " ok" : "");
  }
  async function waitIce(peer) {
    if (peer.iceGatheringState === "complete") return;
    await new Promise(res => peer.addEventListener("icegatheringstatechange", () => {
      if (peer.iceGatheringState === "complete") res();
    }));
  }
  function resetP2P() {
    if (dc) { try { dc.close(); } catch {} dc = null; }
    if (pc) { try { pc.close(); } catch {} pc = null; }
    role = null; p2pBadge.textContent = "P2P: disconnected";
  }
  function p2pSend(obj) {
    if (!dc || dc.readyState !== "open") return;
    try { dc.send(JSON.stringify(obj)); } catch {}
  }
  function handleMsg(msg) {
    if (!msg || typeof msg !== "object") return;
    if (msg.t === "inp") {
      // remote input update goes into remoteInput
      remoteInput[msg.i] = !!msg.v;
    } else if (msg.t === "state") {
      if (role === "join") {
        unpackInto(P1, msg.p1);
        unpackInto(P2, msg.p2);
      }
    }
  }
})();
</script>
</body>
</html>
